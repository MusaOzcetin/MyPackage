var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started-with-Neat.jl","page":"Getting Started","title":"Getting Started with Neat.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Welcome to Neat.jl – a Julia implementation of the NEAT (NeuroEvolution of Augmenting Topologies) algorithm.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This guide will walk you through setting up and running your first experiment using Neat.jl.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/#Requirements","page":"Getting Started","title":"Requirements","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Julia 1.8 or newer (recommended: Julia 1.11+)\nGit (for cloning the repo)\nVS Code or any Julia-compatible editor (optional)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#1.-Clone-the-repository","page":"Getting Started","title":"1. Clone the repository","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Clone the repository and activate the environment.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/your-username/Neat.jl.git\ncd Neat.jl","category":"page"},{"location":"getting_started/#2.-Basic-Working-Example","page":"Getting Started","title":"2. Basic Working Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Creating, evaluating, mutating, and evolving genomes.","category":"page"},{"location":"getting_started/#2.1.-Create-a-minimal-genome","page":"Getting Started","title":"2.1. Create a minimal genome","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Creating a genome with 2 input and 1 output node.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Neat\n\ngenome = create_genome(2, 1)\nprintln(\"Created genome with ID: \", genome.id)\nprintln(\"Number of nodes: \", length(genome.nodes))\nprintln(\"Number of connections: \", length(genome.connections))","category":"page"},{"location":"getting_started/#2.2.-Evaluate-fitness","page":"Getting Started","title":"2.2. Evaluate fitness","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Evaluate the genome on a simple XOR task using evaluate_fitness.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"fitness_before = evaluate_fitness(genome)\ngenome.fitness = fitness_before\nprintln(\"Fitness before mutation: \", round(fitness_before, digits=4))","category":"page"},{"location":"getting_started/#2.3.-Mutate-the-genome","page":"Getting Started","title":"2.3. Mutate the genome","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Apply random structural and weight mutations to the genome.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"mutate(genome)\n\nprintln(\"After mutation:\")\nprintln(\"Number of nodes: \", length(genome.nodes))\nprintln(\"Number of connections: \", length(genome.connections))","category":"page"},{"location":"getting_started/#2.4.-Re-evaluate-fitness-after-mutation","page":"Getting Started","title":"2.4. Re-evaluate fitness after mutation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Re-evaluate the modified genome to observe fitness change.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"fitness_after = evaluate_fitness(genome)\ngenome.fitness = fitness_after\nprintln(\"Fitness after mutation: \", round(fitness_after, digits=4))","category":"page"},{"location":"getting_started/#2.5.-Simulate-simple-evolution","page":"Getting Started","title":"2.5. Simulate simple evolution","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Create a small population, evaluates fitness, and mutates over generations.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"population = [create_genome(2, 1) for _ in 1:10]\n\nfor generation in 1:10\n    println(\"\\nGeneration $generation\")\n    # Evaluate fitness\n    for g in population\n        g.fitness = evaluate_fitness(g)\n    end\n\n    # Print best fitness this generation\n    fitnesses = [g.fitness for g in population]\n    println(\"Best fitness: \", round(maximum(fitnesses), digits=4))\n\n    # Mutate all genomes for next generation\n    for g in population\n        mutate(g)\n    end\nend","category":"page"},{"location":"getting_started/#3.-NEAT-Features-Supported","page":"Getting Started","title":"3. NEAT Features Supported","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Species tracking and reproduction using speciation.jl\nMutation operators for weights, nodes, and connections\nCrossover-based reproduction instead of mutation-only\nTraining over multiple generations with evolve_generation() or train()","category":"page"},{"location":"#Neat","page":"Home","title":"Neat","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Neat.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Neat.NeatConfig.DEFAULT_CONFIG","page":"Home","title":"Neat.NeatConfig.DEFAULT_CONFIG","text":"DEFAULT_CONFIG :: Dict{String,Any}\n\nA Dict specifying default settings for population, mutation, crossover, and speciation.\n\n\n\n\n\n","category":"constant"},{"location":"#Neat.NeatConfig._default_toml_path-Tuple{}","page":"Home","title":"Neat.NeatConfig._default_toml_path","text":"defaulttoml_path() -> String\n\nReturn the file path for the TOML configuration file (neat_config.toml) in the current working directory.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.NeatConfig.load_config-Tuple{}","page":"Home","title":"Neat.NeatConfig.load_config","text":"load_config() -> Dict{String,Any}\n\nLoad the configuration from neat_config.toml. If the file does not exist, write the DEFAULT_CONFIG to that file first, then parse and return it. If the file exists, log that the existing configuration is being used.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.CreateGenome.create_genome-Tuple{Int64, Int64}","page":"Home","title":"Neat.CreateGenome.create_genome","text":"create_genome(num_inputs::Int, num_outputs::Int) → Genome\n\nCreates a Genome with:\n\nThe specified number of input nodes\nThe specified number of output nodes\nFully connected input-to-output connections with random weights\n\nNO HIDDEN NODES ARE CREATED INITIALLY\n\nArguments\n\nnum_inputs::Int: Number of input nodes.\nnum_outputs::Int: Number of output nodes.\n\nReturns\n\nGenome: A new genome with nodes and fully connected input-output links.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.CreateGenome.next_genome_id-Tuple{}","page":"Home","title":"Neat.CreateGenome.next_genome_id","text":"next_genome_id() → Int\n\nReturns the next global node id.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.CreateGenome.reset_genome_id!-Tuple{}","page":"Home","title":"Neat.CreateGenome.reset_genome_id!","text":"reset_id!()\n\nResets the counter (useful for tests).\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Fitness.evaluate_fitness-Tuple{Genome}","page":"Home","title":"Neat.Fitness.evaluate_fitness","text":"evaluate_fitness(genome::Genome; ds_name::Union{String,Missing}=missing) -> Float64\n\nCompute the fitness of a genome on a specified dataset by running its neural network and summing the squared errors between outputs and targets, then returning the negative total error.\n\nA more positive return value indicates better performance (lower overall error).\n\nKeyword Arguments\n\ngenome : The Genome whose network will be evaluated.\nds_name : Optional name of the dataset to use (e.g., \"XOR_DATA\" or \"PARITY3_DATA\").             If not defined, the default training_data key from the configuration is used.\n\nReturns\n\nFloat64 : Negative sum of squared errors over all input–target pairs in the dataset.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.ForwardPass.forward_pass-Tuple{Genome, Vector{Float64}}","page":"Home","title":"Neat.ForwardPass.forward_pass","text":"forward_pass(genome::Genome, input::Vector{Float64}) → Dict{Int, Float64}\n\nPerforms a forward pass through the network defined by genome, computing activation values for all nodes.\n\nArguments\n\ngenome::Genome: The genome containing nodes and connections.\ninput::Vector{Float64}: Activation values for input nodes.\n\nReturns\n\nDict{Int, Float64}: A dictionary mapping each node ID to its activation value.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.ForwardPass.topological_sort-Tuple{Genome}","page":"Home","title":"Neat.ForwardPass.topological_sort","text":"topological_sort(genome::Genome) → Vector{Int}\n\nPerforms a topological sort of all nodes in the genome. The resulting order ensures each node appears only after all its predecessors have been processed.\n\nArguments\n\ngenome::Genome: The genome containing nodes and connections.\n\nReturns\n\nVector{Int}: A list of node IDs in a valid computation order.\n\nErrors\n\nThrows an error if the graph contains cycles, making topological sorting impossible.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.add_connection!-Tuple{Genome}","page":"Home","title":"Neat.Mutation.add_connection!","text":"add_connection!(genome::Genome; max_attempts::Int=50) -> Nothing\n\nTry up to max_attempts times to add a new connection between two previously unconnected nodes without creating a cycle.\n\nSelects random input and output nodes (skipping invalid or existing edges) until a valid pair is found or attempts exhausted.\n\nKeyword Arguments\n\nmax_attempts : Maximum number of trials before giving up (default: 50).\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.add_node!-Tuple{Genome}","page":"Home","title":"Neat.Mutation.add_node!","text":"add_node!(genome::Genome) -> Nothing\n\nInsert a new hidden node by splitting an existing enabled connection.\n\nChooses a random enabled connection A → B and disables it.\nCreates a new hidden node C with a unique ID.\nAdds two connections: A → C (weight = 1.0) and C → B (weight equal to the original connection).\n\nThis mutation allows the network topology to grow.\n\nArguments\n\ngenome : The Genome to modify.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.causes_cycle-Tuple{Genome, Int64, Int64}","page":"Home","title":"Neat.Mutation.causes_cycle","text":"causes_cycle(genome::Genome, src_id::Int, dst_id::Int) -> Bool\n\nDetermine whether adding a connection from node src_id to dst_id would introduce a cycle.\n\nPerforms a depth-first search starting from dst_id to see if src_id is reachable.\n\nArguments\n\ngenome : The Genome whose topology is checked.\nsrc_id : Identifier of the potential source node.\ndst_id : Identifier of the potential destination node.\n\nReturns\n\ntrue if a path exists from dst_id back to src_id (a cycle would form), otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.mutate-Tuple{Genome}","page":"Home","title":"Neat.Mutation.mutate","text":"mutate(genome::Genome; perturb_chance, sigma, add_connection_prob, node_add_prob, max_attempts) -> Nothing\n\nApply a full suite of mutation operators to genome according to configured probabilities.\n\nWeight mutations via mutate_weights!.\nWith probability add_connection_prob, attempt add_connection!.\nWith probability node_add_prob, attempt add_node!.\n\nIf any probability or max_attempts is not defined, the value is loaded from the mutation section of the configuration.\n\nKeyword Arguments\n\nperturb_chance : Probability for weight perturbation.\nsigma : Stddev for weight perturbation.\nadd_connection_prob : Chance to add a new connection.\nnode_add_prob : Chance to add a new node.\nmax_attempts : Max trials for adding a connection.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.mutate_weights!-Tuple{Genome}","page":"Home","title":"Neat.Mutation.mutate_weights!","text":"mutate_weights!(genome::Genome; perturb_chance::Float64, sigma::Float64) -> Nothing\n\nApply weight mutations to all connections of genome in-place.\n\nWith probability perturb_chance, add a perturbation drawn from Normal(0, sigma).\nOtherwise, assign a completely new weight sampled from Normal(0, 1).\n\nArguments\n\ngenome : The Genome whose connection weights will be mutated.\nperturb_chance : Probability of choosing a small perturbation over full replacement.\nsigma : Standard deviation of the Gaussian perturbation.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Population.initialize_population-Tuple{Int64, Int64, Int64}","page":"Home","title":"Neat.Population.initialize_population","text":"initialize_population(num_genomes::Int, num_inputs::Int, num_outputs::Int) → Vector{Genome}\n\nCreate a population of n genomes initialized with given number of input/output nodes. Each genome is assigned a unique ID.\n\nArguments\n\nnum_genomes: Number of genomes to create.\nnum_inputs: Number of input nodes.\nnum_outputs: Number of output nodes.\n\nReturns\n\nA vector of Genome objects.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Crossover.crossover-Tuple{Genome, Genome}","page":"Home","title":"Neat.Crossover.crossover","text":"crossover(parent1::Genome, parent2::Genome) → Genome\n\nPerform crossover between two parent genomes.   The fitter parent contributes all disjoint and excess genes.   Matching genes are randomly inherited from either parent.   Disabled genes may remain disabled in the child.\n\nArguments\n\nparent1::Genome: One parent genome.\nparent2::Genome: Another parent genome.\n\nReturns\n\nGenome: A new child genome composed from both parents' genes.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.adjust_fitness!-Tuple{Vector{Vector{Genome}}}","page":"Home","title":"Neat.Speciation.adjust_fitness!","text":"adjust_fitness!(species_list::Vector{Vector{Genome}})\n\nApplies fitness sharing to scale each genome’s fitness relative to its species size.\n\nModifies each genome's fitness value in-place by applying NEAT-style fitness sharing:\n\nDivides each genome's fitness by the number of members in its species.\n\nArguments\n\nspecies_list : A vector of species (each a vector of genomes).\n\nSide Effects\n\nSets each genome’s adjusted_fitness to fitness / species_size.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.assign_species!-Tuple{Vector{Genome}, Vector{Vector{Genome}}}","page":"Home","title":"Neat.Speciation.assign_species!","text":"assign_species!(population::Vector{Genome}, species_list::Vector{Vector{Genome}}; speciation_threshold::Union{Float64,Missing}=missing, c1::Union{Float64,Missing}=missing, c2::Union{Float64,Missing}=missing, c3::Union{Float64,Missing}=missing)\n\nDivide a population of genomes into species based on compatibility distance.\n\nFor each genome (in random order), compute its distance to the representative of each existing species (the first member). If the smallest distance is ≤ speciation_threshold, add it to that species; otherwise, start a new species with this genome as its representative.\n\nIf speciation_threshold, c1, c2, or c3 is missing, the corresponding value is loaded from the training parameters in the configuration.\n\nArguments\n\npopulation : Vector of genomes to classify.\nspecies_list : Vector of species (each a vector of genomes) to populate.\nspeciation_threshold : Maximum compatibility distance to join an existing species.\nc1, c2, c3 : Coefficients forwarded to compatibility_distance.\n\nSide Effects\n\nClears and reassigns species_list in-place.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.compatibility_distance-Tuple{Genome, Genome}","page":"Home","title":"Neat.Speciation.compatibility_distance","text":"compatibility_distance(g1::Genome, g2::Genome; c1::Union{Float64,Missing}=missing, c2::Union{Float64,Missing}=missing, c3::Union{Float64,Missing}=missing) -> Float64\n\nCompute the NEAT compatibility distance between two genomes:\n\nδ = (c1 * E / N) + (c2 * D / N) + (c3 * W)\n\nwhere\n\nE is the number of excess genes,\nD is the number of disjoint genes,\nW is the average weight difference of matching genes,\nN is the number of genes in the larger genome (treated as 1 if small for stability).\n\nIf any of c1, c2, or c3 is not defined, its value is loaded from the speciation section of the configuration.\n\nArguments\n\ng1, g2 : The two Genome instances to compare.\nc1 : Coefficient for excess genes.\nc2 : Coefficient for disjoint genes.\nc3 : Coefficient for average weight differences.\n\nReturns\n\nFloat64 : The compatibility distance (lower means more similar).\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.compute_offspring_counts","page":"Home","title":"Neat.Speciation.compute_offspring_counts","text":"compute_offspring_counts(species_list::Vector{Vector{Genome}}, population_size::Int=300) -> Vector{Int}\n\nAllocate the total number of offspring among species proportionally to their total adjusted fitness.\n\nArguments\n\nspecies_list : List of species (each a vector of genomes).\npopulation_size : Total number of offspring to distribute.\n\nReturns\n\nA vector of integers indicating the offspring count for each species (in the same order).\n\n\n\n\n\n","category":"function"},{"location":"#Neat.Speciation.select_elites-Union{Tuple{T}, Tuple{Vector{T}, Float64}} where T","page":"Home","title":"Neat.Speciation.select_elites","text":"select_elites(species::Vector{T}, elite_frac::Float64) where {T}\n\nSelect the top-performing genomes in a species based on adjusted fitness.\n\nArguments\n\nspecies : Vector of genomes (each with an adjusted_fitness field).\nelite_frac : Fraction of the species to keep as elites (e.g., 0.1 for 10%).\n\nReturns\n\nA vector of the top ceil(elite_frac * length(species)) genomes, sorted by descending adjusted_fitness.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Innovation.get_innovation_number-Tuple{Int64, Int64}","page":"Home","title":"Neat.Innovation.get_innovation_number","text":"Returns a unique innovation number for the connection from in_node to out_node. If this connection has been seen before, returns the previously assigned number. Otherwise, assigns a new innovation number and stores it. Used in NEAT to track structural mutations consistently across genomes. !Ensures that even if two genomes both add a connection from node A → B, they will NOT get different innovation numbers.\n\nReturns\n\nInt: The innovation number for the (innode, outnode) pair.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Innovation.reset_innovation_counter!-Tuple{}","page":"Home","title":"Neat.Innovation.reset_innovation_counter!","text":"reset_innovation_counter!()\n\nResets the counter (useful for tests).\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Visualize.plot_fitness_history-Tuple{Vector{Float64}}","page":"Home","title":"Neat.Visualize.plot_fitness_history","text":"plot_fitness_history(best_fitness_history; filename=\"fitness_history.png\")\n\nCreate and save a line plot of the best fitness values over generations.\n\nArguments\n\nbest_fitness_history::Vector{Float64}: History of best fitness per generation.\nfilename::String: Output file path (defaults to \"fitness_history.png\").\n\n\n\n\n\n","category":"method"}]
}
