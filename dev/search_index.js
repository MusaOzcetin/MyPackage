var documenterSearchIndex = {"docs":
[{"location":"#Neat","page":"Home","title":"Neat","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Neat.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Neat.CreateGenome.create_genome-Tuple{Int64, Int64, Int64}","page":"Home","title":"Neat.CreateGenome.create_genome","text":"create_genome(id::Int, num_inputs::Int, num_outputs::Int) → Genome\n\nCreates a Genome with:\n\nThe specified number of input nodes\nThe specified number of output nodes\nFully connected input-to-output connections with random weights\n\nNO HIDDEN NODES ARE CREATED INITIALLY\n\nArguments\n\nid::Int: Unique genome ID.\nnum_inputs::Int: Number of input nodes.\nnum_outputs::Int: Number of output nodes.\n\nReturns\n\nGenome: A new genome with nodes and fully connected input-output links.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Fitness.evaluate_fitness-Tuple{Genome}","page":"Home","title":"Neat.Fitness.evaluate_fitness","text":"evaluate_fitness(genome::Genome) → Float64\n\nEvaluate a Genome’s performance on the XOR task by summing squared errors  for all four input–output pairs and returning the negative total error.\n\nArguments\n\ngenome::Genome: The genome whose neural network weights are tested on XOR.\n\nReturns\n\nFloat64: The negative sum of squared errors over the four XOR cases. (Higher value ⇒ lower error ⇒ better fitness.)\n\n\n\n\n\n","category":"method"},{"location":"#Neat.ForwardPass.forward_pass-Tuple{Genome, Vector{Float64}}","page":"Home","title":"Neat.ForwardPass.forward_pass","text":"forward_pass(genome::Genome, input::Vector{Float64}) → Dict{Int, Float64}\n\nPerforms a forward pass through the network defined by genome, computing activation values for all nodes.\n\nArguments\n\ngenome::Genome: The genome containing nodes and connections.\ninput::Vector{Float64}: Activation values for input nodes.\n\nReturns\n\nDict{Int, Float64}: A dictionary mapping each node ID to its activation value.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.ForwardPass.topological_sort-Tuple{Genome}","page":"Home","title":"Neat.ForwardPass.topological_sort","text":"topological_sort(genome::Genome) → Vector{Int}\n\nPerforms a topological sort of all nodes in the genome. The resulting order ensures each node appears only after all its predecessors have been processed.\n\nArguments\n\ngenome::Genome: The genome containing nodes and connections.\n\nReturns\n\nVector{Int}: A list of node IDs in a valid computation order.\n\nErrors\n\nThrows an error if the graph contains cycles, making topological sorting impossible.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.add_connection!-Tuple{Genome}","page":"Home","title":"Neat.Mutation.add_connection!","text":"add_connection!(genome::Genome)\n\nAttempts to add a new connection between two previously unconnected nodes.\n\nRandomly selects two nodes from the genome.\nEnsures they are not already connected.\nEnsures the direction respects feedforward constraints (no output → input).\nChecks for cycles\nAdds the new connection with a random weight and a new innovation number.\n\nDoes nothing if no valid pair is found after 50 attempts.\n\nArguments\n\ngenome: The genome to mutate (in-place).\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.add_node!-Tuple{Genome}","page":"Home","title":"Neat.Mutation.add_node!","text":"add_node!(genome::Genome)\n\nInserts a new hidden node by splitting an existing active connection.\n\nRandomly selects an enabled connection A → B.\nDisables the original connection.\nCreates a new hidden node C.\nAdds two new connections:\nA → C (weight = 1.0)\nC → B (inherits original weight)\n\nThis mutation allows the network to grow and change its topology.\n\nArguments\n\ngenome: The genome to mutate (in-place).\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.causes_cycle-Tuple{Genome, Int64, Int64}","page":"Home","title":"Neat.Mutation.causes_cycle","text":"HELPER: causescycle(genome, srcid, dst_id)\n\nChecks if adding a connection from src_id to dst_id would create a cycle.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.mutate-Tuple{Genome}","page":"Home","title":"Neat.Mutation.mutate","text":"mutate(genome)\n\nApplies all mutation operators to a genome.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Mutation.mutate_weights!-Tuple{Genome}","page":"Home","title":"Neat.Mutation.mutate_weights!","text":"mutate_weights!(genome; perturb_chance=0.8, sigma=0.5)\n\nMutates the weights of a genome's connections in-place.\n\nWith perturb_chance probability: Perturb weight by adding N(0, sigma)\nOtherwise: Replace weight with a new random value (randn())\n\nArguments\n\ngenome: The genome to mutate\nperturb_chance: Chance of small mutation vs full replacement\nsigma: Stddev of the perturbation\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Population.initialize_population-Tuple{Int64, Int64, Int64}","page":"Home","title":"Neat.Population.initialize_population","text":"initialize_population(num_genomes::Int, num_inputs::Int, num_outputs::Int) → Vector{Genome}\n\nCreate a population of n genomes initialized with given number of input/output nodes. Each genome is assigned a unique ID.\n\nArguments\n\nnum_genomes: Number of genomes to create.\nnum_inputs: Number of input nodes.\nnum_outputs: Number of output nodes.\n\nReturns\n\nA vector of Genome objects.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Crossover.crossover-Tuple{Genome, Genome}","page":"Home","title":"Neat.Crossover.crossover","text":"crossover(parent1::Genome, parent2::Genome) → Genome\n\nPerform crossover between two parent genomes.   The fitter parent contributes all disjoint and excess genes.   Matching genes are randomly inherited from either parent.   Disabled genes may remain disabled in the child.\n\nArguments\n\nparent1::Genome: One parent genome.\nparent2::Genome: Another parent genome.\n\nReturns\n\nGenome: A new child genome composed from both parents' genes.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.adjust_fitness!-Tuple{Vector{Vector{Genome}}}","page":"Home","title":"Neat.Speciation.adjust_fitness!","text":"adjust_fitness!(species_list::Vector{Vector{Genome}})\n\nApplies fitness sharing to scale each genome’s fitness relative to its species size.\n\nModifies each genome's fitness value in-place by applying NEAT-style fitness sharing:\n\nDivides each genome's fitness by the number of members in its species.\n\nArguments\n\nspecies_list: A vector of species, where each species is a vector of genomes.\n\nSide Effect\n\nOverwrites each genome's fitness value with the adjusted fitness.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.assign_species!-Tuple{Vector{Genome}, Vector{Vector{Genome}}}","page":"Home","title":"Neat.Speciation.assign_species!","text":"assign_species!(population::Vector{Genome}, species_list::Vector{Vector{Genome}};\n                threshold=3.0)\n\nGroups genomes into species based on compatibility.\n\nAssign each genome in the population to a species in species_list based on compatibility distance. A genome is added to the first species where distance to the representative is below the threshold. If no such species exists, a new species is created with this genome.\n\nArguments\n\npopulation: Vector of genomes to classify\nspecies_list: Vector of species (each a vector of genomes)\nthreshold: Maximum allowed compatibility distance to join a species\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.compatibility_distance-Tuple{Genome, Genome}","page":"Home","title":"Neat.Speciation.compatibility_distance","text":"compatibility_distance(g1::Genome, g2::Genome;\n                       c1=1.0, c2=1.0, c3=0.4) → Float64\n\nCompute the compatibility distance between two genomes g1 and g2 (similarity between genomes using innovation numbers and weights). Uses NEAT's distance formula:\n\nδ = (c1 * E / N) + (c2 * D / N) + (c3 * W)\n\nE = number of excess genes\nD = number of disjoint genes\nW = average weight difference of matching genes\nN = number of genes in the larger genome (set to 1 if small for stability)\n\nKeyword Arguments\n\nc1, c2, c3: importance of each factor\n\nReturns\n\nA Float64 distance value (lower means more similar)\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.compute_offspring_counts-Tuple{Vector{Vector{Genome}}, Int64}","page":"Home","title":"Neat.Speciation.compute_offspring_counts","text":"compute_offspring_counts(species_list::Vector{Vector{Genome}}, population_size::Int) → Vector{Int}\n\nCalculates how many offspring each species is allowed to produce based on the sum of adjusted fitness values in each species, relative to the population's total.\n\nArguments\n\nspecies_list: List of species (each is a list of genomes)\npopulation_size: Total number of offspring to allocate\n\nReturns\n\nVector{Int}: A list of offspring counts per species (same order)\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.select_elites-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T","page":"Home","title":"Neat.Speciation.select_elites","text":"select_elites(species::Vector{T}, num_elites::Int) where T\n\nSelects the top num_elites genomes from the given species based on their adjusted_fitness.\n\nArguments\n\nspecies: a vector of individuals (e.g., Genomes) that have an adjusted_fitness field.\nnum_elites: how many of the top individuals to select.\n\nReturns\n\nA vector of the top-performing individuals, sorted by descending adjusted_fitness.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Speciation.select_parents-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T","page":"Home","title":"Neat.Speciation.select_parents","text":"select_parents(species::Vector{T}, num_parents::Int; exclude::Set{T}=Set()) where T\n\nSelects num_parents pairs of parents using fitness-proportionate (roulette wheel) selection.\n\nArguments\n\nspecies: a vector of individuals with an adjusted_fitness field.\nnum_parents: the number of parent pairs to select.\nexclude: (optional) a set of individuals to skip (e.g., elites).\n\nReturns\n\nA vector of (parent1, parent2) tuples, each selected by roulette wheel based on adjusted_fitness.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Innovation.next_innovation_number-Tuple{}","page":"Home","title":"Neat.Innovation.next_innovation_number","text":"next_innovation_number() → Int\n\nReturns the next global innovation number.\n\n\n\n\n\n","category":"method"},{"location":"#Neat.Innovation.reset_innovation_counter!-Tuple{}","page":"Home","title":"Neat.Innovation.reset_innovation_counter!","text":"reset_innovation_counter!()\n\nResets the counter (useful for tests).\n\n\n\n\n\n","category":"method"}]
}
